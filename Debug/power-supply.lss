
power-supply.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000566  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000400  00802000  00000566  000005da  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  000009da  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000a0c  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 000000a0  00000000  00000000  00000a4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000006f3  00000000  00000000  00000aec  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000002cb  00000000  00000000  000011df  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000042d  00000000  00000000  000014aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000158  00000000  00000000  000018d8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000032f  00000000  00000000  00001a30  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000453  00000000  00000000  00001d5f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000060  00000000  00000000  000021b2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
   8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
   c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  10:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  14:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  18:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  1c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  20:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  24:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  28:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  2c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  30:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  34:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  38:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  3c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  40:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  44:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  48:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  4c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  50:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  54:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  58:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  5c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  60:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  64:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  68:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  6c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  70:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  74:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  78:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  7c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  80:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  84:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  88:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  8c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  90:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  94:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  98:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  9c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  a0:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  a4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  a8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  ac:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  b0:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  b4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  b8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  bc:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  c0:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  c4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  c8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  cc:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  d0:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  d4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  d8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  dc:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  e0:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  e4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  e8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  ec:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  f0:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  f4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  f8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
  fc:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 100:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 104:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 108:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 10c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 110:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 114:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 118:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 11c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 120:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 124:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 128:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 12c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 130:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 134:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 138:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 13c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 140:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 144:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 148:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 14c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 150:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 154:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 158:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 15c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 160:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 164:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 168:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 16c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 170:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 174:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 178:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 17c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 180:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 184:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 188:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 18c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 190:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 194:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 198:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 19c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1a0:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1a4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1a8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1ac:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1b0:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1b4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1b8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1bc:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1c0:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1c4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1c8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1cc:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1d0:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1d4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1d8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1dc:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1e0:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1e4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1e8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1ec:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1f0:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1f4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 1f8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e2       	ldi	r29, 0x2F	; 47
 206:	de bf       	out	0x3e, r29	; 62

00000208 <__do_copy_data>:
 208:	14 e2       	ldi	r17, 0x24	; 36
 20a:	a0 e0       	ldi	r26, 0x00	; 0
 20c:	b0 e2       	ldi	r27, 0x20	; 32
 20e:	e6 e6       	ldi	r30, 0x66	; 102
 210:	f5 e0       	ldi	r31, 0x05	; 5
 212:	02 c0       	rjmp	.+4      	; 0x218 <__do_copy_data+0x10>
 214:	05 90       	lpm	r0, Z+
 216:	0d 92       	st	X+, r0
 218:	a0 30       	cpi	r26, 0x00	; 0
 21a:	b1 07       	cpc	r27, r17
 21c:	d9 f7       	brne	.-10     	; 0x214 <__do_copy_data+0xc>
 21e:	0e 94 2f 01 	call	0x25e	; 0x25e <main>
 222:	0c 94 b1 02 	jmp	0x562	; 0x562 <_exit>

00000226 <__bad_interrupt>:
 226:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000022a <clkInit>:
#include "init.h"
#include "pindefs.h"

void clkInit(void){
	// internal 32MHz oscillator
	CLK_CTRL = CLK_SCLKSEL_RC32M_gc;
 22a:	81 e0       	ldi	r24, 0x01	; 1
 22c:	80 93 40 00 	sts	0x0040, r24
 230:	08 95       	ret

00000232 <pinInit>:
}

void pinInit(void){
	// setup output pins
	PORTD_DIRSET = (1<<OLED_RST | 1<<OLED_DC | 1<<OLED_CS | 1<<OLED_MOSI | 1<<OLED_SCK);
 232:	8c eb       	ldi	r24, 0xBC	; 188
 234:	80 93 61 06 	sts	0x0661, r24
	// setup input pins, this isnt actually needed; pins are inputs by default
	PORTC_DIRCLR = (1<<CLIM);
 238:	81 e0       	ldi	r24, 0x01	; 1
 23a:	80 93 42 06 	sts	0x0642, r24
	PORTD_DIRCLR = (1<<ENC1A | 1<<ENC1B);
 23e:	83 e0       	ldi	r24, 0x03	; 3
 240:	80 93 62 06 	sts	0x0662, r24
	PORTE_DIRCLR = (1<<ENC2A | 1<<ENC2B | 1<<ENC1SW | 1<<ENC2SW);
 244:	8f e0       	ldi	r24, 0x0F	; 15
 246:	80 93 82 06 	sts	0x0682, r24
	
	// enable pullups, i wish there was a more compact way to do this
	//PORTD_PIN0CTRL
	PORTE_PIN0CTRL = PORT_OPC_PULLUP_gc;
 24a:	88 e1       	ldi	r24, 0x18	; 24
 24c:	80 93 90 06 	sts	0x0690, r24
	PORTE_PIN1CTRL = PORT_OPC_PULLUP_gc;
 250:	80 93 91 06 	sts	0x0691, r24
	PORTE_PIN2CTRL = PORT_OPC_PULLUP_gc;
 254:	80 93 92 06 	sts	0x0692, r24
	PORTE_PIN3CTRL = PORT_OPC_PULLUP_gc;
 258:	80 93 93 06 	sts	0x0693, r24
 25c:	08 95       	ret

0000025e <main>:


int main(void)
{
	// initialize things
	clkInit();
 25e:	0e 94 15 01 	call	0x22a	; 0x22a <clkInit>
	pinInit();
 262:	0e 94 19 01 	call	0x232	; 0x232 <pinInit>
	spiBegin(SPI_PORTC, 5, MOSI, MISO, SCK, ADC_CS, DAC_CS);
 266:	1f 92       	push	r1
 268:	82 e0       	ldi	r24, 0x02	; 2
 26a:	8f 93       	push	r24
 26c:	1f 92       	push	r1
 26e:	d1 e0       	ldi	r29, 0x01	; 1
 270:	df 93       	push	r29
 272:	1f 92       	push	r1
 274:	17 e0       	ldi	r17, 0x07	; 7
 276:	1f 93       	push	r17
 278:	1f 92       	push	r1
 27a:	86 e0       	ldi	r24, 0x06	; 6
 27c:	8f 93       	push	r24
 27e:	1f 92       	push	r1
 280:	c5 e0       	ldi	r28, 0x05	; 5
 282:	cf 93       	push	r28
 284:	cf 93       	push	r28
 286:	1f 92       	push	r1
 288:	0e 94 03 02 	call	0x406	; 0x406 <spiBegin>
	spiBegin(SPI_PORTD, 3, OLED_MOSI, OLED_SCK, OLED_CS);
 28c:	1f 92       	push	r1
 28e:	84 e0       	ldi	r24, 0x04	; 4
 290:	8f 93       	push	r24
 292:	1f 92       	push	r1
 294:	1f 93       	push	r17
 296:	1f 92       	push	r1
 298:	cf 93       	push	r28
 29a:	83 e0       	ldi	r24, 0x03	; 3
 29c:	8f 93       	push	r24
 29e:	df 93       	push	r29
 2a0:	0e 94 03 02 	call	0x406	; 0x406 <spiBegin>
	
	oledBegin();
 2a4:	0e 94 7d 01 	call	0x2fa	; 0x2fa <oledBegin>
	oledUpdate();
 2a8:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <oledUpdate>
 2ac:	8d b7       	in	r24, 0x3d	; 61
 2ae:	9e b7       	in	r25, 0x3e	; 62
 2b0:	44 96       	adiw	r24, 0x14	; 20
 2b2:	8d bf       	out	0x3d, r24	; 61
 2b4:	9e bf       	out	0x3e, r25	; 62
	
	// loop 5ever
    while (1) 
    {
 		if((PORTE_IN >> ENC1SW) & 1){
 2b6:	e8 e8       	ldi	r30, 0x88	; 136
 2b8:	f6 e0       	ldi	r31, 0x06	; 6
			PORTC_OUTSET = 1<<ADC_CS;
		}else{
			PORTC_OUTCLR = 1<<ADC_CS;
 2ba:	c6 e4       	ldi	r28, 0x46	; 70
 2bc:	d6 e0       	ldi	r29, 0x06	; 6
 2be:	92 e0       	ldi	r25, 0x02	; 2
	
	// loop 5ever
    while (1) 
    {
 		if((PORTE_IN >> ENC1SW) & 1){
			PORTC_OUTSET = 1<<ADC_CS;
 2c0:	a5 e4       	ldi	r26, 0x45	; 69
 2c2:	b6 e0       	ldi	r27, 0x06	; 6
	oledUpdate();
	
	// loop 5ever
    while (1) 
    {
 		if((PORTE_IN >> ENC1SW) & 1){
 2c4:	80 81       	ld	r24, Z
 2c6:	82 ff       	sbrs	r24, 2
 2c8:	02 c0       	rjmp	.+4      	; 0x2ce <main+0x70>
			PORTC_OUTSET = 1<<ADC_CS;
 2ca:	9c 93       	st	X, r25
 2cc:	fb cf       	rjmp	.-10     	; 0x2c4 <main+0x66>
		}else{
			PORTC_OUTCLR = 1<<ADC_CS;
 2ce:	98 83       	st	Y, r25
 2d0:	f9 cf       	rjmp	.-14     	; 0x2c4 <main+0x66>

000002d2 <oledWriteCmd>:
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

void oledWriteCmd(uint8_t cmd){
 2d2:	1f 93       	push	r17
 2d4:	cf 93       	push	r28
 2d6:	df 93       	push	r29
	// begin pins
	PORTD_OUTSET = 1<<OLED_CS;
 2d8:	c5 e6       	ldi	r28, 0x65	; 101
 2da:	d6 e0       	ldi	r29, 0x06	; 6
 2dc:	10 e1       	ldi	r17, 0x10	; 16
 2de:	18 83       	st	Y, r17
	PORTD_OUTCLR = (1<<OLED_DC | 1<<OLED_CS);
 2e0:	98 e1       	ldi	r25, 0x18	; 24
 2e2:	90 93 66 06 	sts	0x0666, r25
	
	// write command
	spiWrite(SPI_PORTD, cmd);
 2e6:	68 2f       	mov	r22, r24
 2e8:	81 e0       	ldi	r24, 0x01	; 1
 2ea:	90 e0       	ldi	r25, 0x00	; 0
 2ec:	0e 94 9c 02 	call	0x538	; 0x538 <spiWrite>
	
	// cs high
	PORTD_OUTSET = 1<<OLED_CS;
 2f0:	18 83       	st	Y, r17
}
 2f2:	df 91       	pop	r29
 2f4:	cf 91       	pop	r28
 2f6:	1f 91       	pop	r17
 2f8:	08 95       	ret

000002fa <oledBegin>:

void oledBegin(void){
	// reset high
	PORTD_OUTSET = 1<<OLED_RST;
 2fa:	e5 e6       	ldi	r30, 0x65	; 101
 2fc:	f6 e0       	ldi	r31, 0x06	; 6
 2fe:	84 e0       	ldi	r24, 0x04	; 4
 300:	80 83       	st	Z, r24
	...
	// chill
	nop();
	nop();
	nop();
	nop();
	PORTD_OUTCLR = 1<<OLED_RST;
 30a:	80 93 66 06 	sts	0x0666, r24
	...
	nop();
	nop();
	nop();
	nop();
	nop();
	PORTD_OUTSET = 1<<OLED_RST;
 31e:	80 83       	st	Z, r24
	
	// Init sequence for 128x64 OLED module
	oledWriteCmd(SSD1306_DISPLAYOFF);			// 0xAE
 320:	8e ea       	ldi	r24, 0xAE	; 174
 322:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_SETDISPLAYCLOCKDIV);	// 0xD5
 326:	85 ed       	ldi	r24, 0xD5	; 213
 328:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(0x80);							// the suggested ratio 0x80
 32c:	80 e8       	ldi	r24, 0x80	; 128
 32e:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_SETMULTIPLEX);			// 0xA8
 332:	88 ea       	ldi	r24, 0xA8	; 168
 334:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(0x3F);
 338:	8f e3       	ldi	r24, 0x3F	; 63
 33a:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_SETDISPLAYOFFSET);		// 0xD3
 33e:	83 ed       	ldi	r24, 0xD3	; 211
 340:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(0x0);							// no offset
 344:	80 e0       	ldi	r24, 0x00	; 0
 346:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_SETSTARTLINE | 0x0);	// line #0
 34a:	80 e4       	ldi	r24, 0x40	; 64
 34c:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_CHARGEPUMP);			// 0x8D
 350:	8d e8       	ldi	r24, 0x8D	; 141
 352:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(0x14);
 356:	84 e1       	ldi	r24, 0x14	; 20
 358:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_MEMORYMODE);			// 0x20
 35c:	80 e2       	ldi	r24, 0x20	; 32
 35e:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(0x00);							// 0x0 act like ks0108
 362:	80 e0       	ldi	r24, 0x00	; 0
 364:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_SEGREMAP | 0x1);
 368:	81 ea       	ldi	r24, 0xA1	; 161
 36a:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_COMSCANDEC);
 36e:	88 ec       	ldi	r24, 0xC8	; 200
 370:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_SETCOMPINS);			// 0xDA
 374:	8a ed       	ldi	r24, 0xDA	; 218
 376:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(0x12);
 37a:	82 e1       	ldi	r24, 0x12	; 18
 37c:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_SETCONTRAST);			// 0x81
 380:	81 e8       	ldi	r24, 0x81	; 129
 382:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(0xCF);
 386:	8f ec       	ldi	r24, 0xCF	; 207
 388:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_SETPRECHARGE);			// 0xd9
 38c:	89 ed       	ldi	r24, 0xD9	; 217
 38e:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(0xF1);
 392:	81 ef       	ldi	r24, 0xF1	; 241
 394:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_SETVCOMDETECT);		// 0xDB
 398:	8b ed       	ldi	r24, 0xDB	; 219
 39a:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(0x40);
 39e:	80 e4       	ldi	r24, 0x40	; 64
 3a0:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_DISPLAYALLON_RESUME);	// 0xA4
 3a4:	84 ea       	ldi	r24, 0xA4	; 164
 3a6:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_NORMALDISPLAY);		// 0xA6
 3aa:	86 ea       	ldi	r24, 0xA6	; 166
 3ac:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_DISPLAYON);			// turn on oled panel
 3b0:	8f ea       	ldi	r24, 0xAF	; 175
 3b2:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
 3b6:	08 95       	ret

000003b8 <oledUpdate>:
}

void oledUpdate(void){
 3b8:	0f 93       	push	r16
 3ba:	1f 93       	push	r17
 3bc:	cf 93       	push	r28
 3be:	df 93       	push	r29
	oledWriteCmd(SSD1306_SETLOWCOLUMN | 0x00);
 3c0:	80 e0       	ldi	r24, 0x00	; 0
 3c2:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_SETHIGHCOLUMN | 0x00);
 3c6:	80 e1       	ldi	r24, 0x10	; 16
 3c8:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	oledWriteCmd(SSD1306_SETSTARTLINE | 0x00);
 3cc:	80 e4       	ldi	r24, 0x40	; 64
 3ce:	0e 94 69 01 	call	0x2d2	; 0x2d2 <oledWriteCmd>
	
	PORTD_OUTSET = (1<<OLED_CS | 1<<OLED_DC);
 3d2:	88 e1       	ldi	r24, 0x18	; 24
 3d4:	80 93 65 06 	sts	0x0665, r24
	PORTD_OUTCLR = 1<<OLED_CS;
 3d8:	80 e1       	ldi	r24, 0x10	; 16
 3da:	80 93 66 06 	sts	0x0666, r24
 3de:	c0 e0       	ldi	r28, 0x00	; 0
 3e0:	d0 e2       	ldi	r29, 0x20	; 32
 3e2:	00 e0       	ldi	r16, 0x00	; 0
 3e4:	14 e2       	ldi	r17, 0x24	; 36
	
	for(uint16_t i = 0; i < (SSD1306_LCDWIDTH * SSD1306_LCDHEIGHT / 8); i++){
		spiWrite(SPI_PORTD, buffer[i]);
 3e6:	69 91       	ld	r22, Y+
 3e8:	81 e0       	ldi	r24, 0x01	; 1
 3ea:	90 e0       	ldi	r25, 0x00	; 0
 3ec:	0e 94 9c 02 	call	0x538	; 0x538 <spiWrite>
	oledWriteCmd(SSD1306_SETSTARTLINE | 0x00);
	
	PORTD_OUTSET = (1<<OLED_CS | 1<<OLED_DC);
	PORTD_OUTCLR = 1<<OLED_CS;
	
	for(uint16_t i = 0; i < (SSD1306_LCDWIDTH * SSD1306_LCDHEIGHT / 8); i++){
 3f0:	c0 17       	cp	r28, r16
 3f2:	d1 07       	cpc	r29, r17
 3f4:	c1 f7       	brne	.-16     	; 0x3e6 <oledUpdate+0x2e>
		spiWrite(SPI_PORTD, buffer[i]);
	}
	
	PORTD_OUTSET = 1<<OLED_CS;
 3f6:	80 e1       	ldi	r24, 0x10	; 16
 3f8:	80 93 65 06 	sts	0x0665, r24
}
 3fc:	df 91       	pop	r29
 3fe:	cf 91       	pop	r28
 400:	1f 91       	pop	r17
 402:	0f 91       	pop	r16
 404:	08 95       	ret

00000406 <spiBegin>:
#include <stdarg.h>
#include "spi.h"
#include "pindefs.h"

// numPins, port, mosi, miso, sck, cs0, cs1, etc.
void spiBegin(uint8_t port, uint8_t numPins, ...){
 406:	ef 92       	push	r14
 408:	ff 92       	push	r15
 40a:	0f 93       	push	r16
 40c:	1f 93       	push	r17
 40e:	cf 93       	push	r28
 410:	df 93       	push	r29
 412:	cd b7       	in	r28, 0x3d	; 61
 414:	de b7       	in	r29, 0x3e	; 62
 416:	99 85       	ldd	r25, Y+9	; 0x09
	// initialize variable number of args
	va_list valist;
	va_start(valist, numPins);
 418:	9e 01       	movw	r18, r28
 41a:	25 5f       	subi	r18, 0xF5	; 245
 41c:	3f 4f       	sbci	r19, 0xFF	; 255
 41e:	f9 01       	movw	r30, r18
	uint8_t pin;
	
	switch(port){
 420:	99 23       	and	r25, r25
 422:	21 f0       	breq	.+8      	; 0x42c <spiBegin+0x26>
 424:	91 30       	cpi	r25, 0x01	; 1
 426:	09 f4       	brne	.+2      	; 0x42a <spiBegin+0x24>
 428:	40 c0       	rjmp	.+128    	; 0x4aa <spiBegin+0xa4>
 42a:	7f c0       	rjmp	.+254    	; 0x52a <spiBegin+0x124>
		case SPI_PORTC:
			// the first pin is always mosi
			pin = (uint8_t)va_arg(valist, int);
 42c:	c9 01       	movw	r24, r18
 42e:	02 96       	adiw	r24, 0x02	; 2
			PORTC_DIRSET = 1<<pin;
 430:	21 e0       	ldi	r18, 0x01	; 1
 432:	30 e0       	ldi	r19, 0x00	; 0
 434:	0b 84       	ldd	r0, Y+11	; 0x0b
 436:	02 c0       	rjmp	.+4      	; 0x43c <spiBegin+0x36>
 438:	22 0f       	add	r18, r18
 43a:	33 1f       	adc	r19, r19
 43c:	0a 94       	dec	r0
 43e:	e2 f7       	brpl	.-8      	; 0x438 <spiBegin+0x32>
 440:	20 93 41 06 	sts	0x0641, r18
			
			// get the remaining pins
			for(uint8_t i = 0; i < numPins - 1; i++){\
 444:	2a 85       	ldd	r18, Y+10	; 0x0a
 446:	62 2f       	mov	r22, r18
 448:	70 e0       	ldi	r23, 0x00	; 0
 44a:	61 50       	subi	r22, 0x01	; 1
 44c:	71 09       	sbc	r23, r1
 44e:	16 16       	cp	r1, r22
 450:	17 06       	cpc	r1, r23
 452:	3c f5       	brge	.+78     	; 0x4a2 <spiBegin+0x9c>
 454:	20 e0       	ldi	r18, 0x00	; 0
				if(pin == 6){
					// miso pin
					PORTC_DIRCLR = 1<<pin;
				}else{
					// the rest are outputs
					PORTC_DIRSET = 1<<pin;
 456:	a1 e0       	ldi	r26, 0x01	; 1
 458:	b0 e0       	ldi	r27, 0x00	; 0
 45a:	01 e4       	ldi	r16, 0x41	; 65
 45c:	16 e0       	ldi	r17, 0x06	; 6
			for(uint8_t i = 0; i < numPins - 1; i++){\
				pin = (uint8_t)va_arg(valist, int);
				
				if(pin == 6){
					// miso pin
					PORTC_DIRCLR = 1<<pin;
 45e:	0f 2e       	mov	r0, r31
 460:	f2 e4       	ldi	r31, 0x42	; 66
 462:	ef 2e       	mov	r14, r31
 464:	f6 e0       	ldi	r31, 0x06	; 6
 466:	ff 2e       	mov	r15, r31
 468:	f0 2d       	mov	r31, r0
			pin = (uint8_t)va_arg(valist, int);
			PORTC_DIRSET = 1<<pin;
			
			// get the remaining pins
			for(uint8_t i = 0; i < numPins - 1; i++){\
				pin = (uint8_t)va_arg(valist, int);
 46a:	fc 01       	movw	r30, r24
 46c:	30 81       	ld	r19, Z
 46e:	02 96       	adiw	r24, 0x02	; 2
				
				if(pin == 6){
 470:	36 30       	cpi	r19, 0x06	; 6
 472:	49 f4       	brne	.+18     	; 0x486 <spiBegin+0x80>
					// miso pin
					PORTC_DIRCLR = 1<<pin;
 474:	ad 01       	movw	r20, r26
 476:	02 c0       	rjmp	.+4      	; 0x47c <spiBegin+0x76>
 478:	44 0f       	add	r20, r20
 47a:	55 1f       	adc	r21, r21
 47c:	3a 95       	dec	r19
 47e:	e2 f7       	brpl	.-8      	; 0x478 <spiBegin+0x72>
 480:	f7 01       	movw	r30, r14
 482:	40 83       	st	Z, r20
 484:	08 c0       	rjmp	.+16     	; 0x496 <spiBegin+0x90>
				}else{
					// the rest are outputs
					PORTC_DIRSET = 1<<pin;
 486:	ad 01       	movw	r20, r26
 488:	02 c0       	rjmp	.+4      	; 0x48e <spiBegin+0x88>
 48a:	44 0f       	add	r20, r20
 48c:	55 1f       	adc	r21, r21
 48e:	3a 95       	dec	r19
 490:	e2 f7       	brpl	.-8      	; 0x48a <spiBegin+0x84>
 492:	f8 01       	movw	r30, r16
 494:	40 83       	st	Z, r20
			// the first pin is always mosi
			pin = (uint8_t)va_arg(valist, int);
			PORTC_DIRSET = 1<<pin;
			
			// get the remaining pins
			for(uint8_t i = 0; i < numPins - 1; i++){\
 496:	2f 5f       	subi	r18, 0xFF	; 255
 498:	42 2f       	mov	r20, r18
 49a:	50 e0       	ldi	r21, 0x00	; 0
 49c:	46 17       	cp	r20, r22
 49e:	57 07       	cpc	r21, r23
 4a0:	24 f3       	brlt	.-56     	; 0x46a <spiBegin+0x64>
					PORTC_DIRSET = 1<<pin;
				}
			}
			
			// enable SPIC, master mode, clk/4 = 8MHz
			SPIC_CTRL = (1<<SPI_ENABLE_bp | 1<<SPI_MASTER_bp);
 4a2:	80 e5       	ldi	r24, 0x50	; 80
 4a4:	80 93 c0 08 	sts	0x08C0, r24
			break;
 4a8:	40 c0       	rjmp	.+128    	; 0x52a <spiBegin+0x124>
		case SPI_PORTD:
			// the first pin is always mosi
			pin = (uint8_t)va_arg(valist, int);
 4aa:	c9 01       	movw	r24, r18
 4ac:	02 96       	adiw	r24, 0x02	; 2
			PORTC_DIR |= 1<<pin;
 4ae:	a0 e4       	ldi	r26, 0x40	; 64
 4b0:	b6 e0       	ldi	r27, 0x06	; 6
 4b2:	4c 91       	ld	r20, X
 4b4:	21 e0       	ldi	r18, 0x01	; 1
 4b6:	30 e0       	ldi	r19, 0x00	; 0
 4b8:	00 80       	ld	r0, Z
 4ba:	02 c0       	rjmp	.+4      	; 0x4c0 <spiBegin+0xba>
 4bc:	22 0f       	add	r18, r18
 4be:	33 1f       	adc	r19, r19
 4c0:	0a 94       	dec	r0
 4c2:	e2 f7       	brpl	.-8      	; 0x4bc <spiBegin+0xb6>
 4c4:	24 2b       	or	r18, r20
 4c6:	2c 93       	st	X, r18
			
			// get the remaining pins
			for(uint8_t i = 0; i < numPins - 1; i++){
 4c8:	fa 85       	ldd	r31, Y+10	; 0x0a
 4ca:	6f 2f       	mov	r22, r31
 4cc:	70 e0       	ldi	r23, 0x00	; 0
 4ce:	61 50       	subi	r22, 0x01	; 1
 4d0:	71 09       	sbc	r23, r1
 4d2:	16 16       	cp	r1, r22
 4d4:	17 06       	cpc	r1, r23
 4d6:	34 f5       	brge	.+76     	; 0x524 <spiBegin+0x11e>
 4d8:	20 e0       	ldi	r18, 0x00	; 0
				if(pin == 6){
					// miso pin
					PORTC_DIRCLR = 1<<pin;
					}else{
					// the rest are outputs
					PORTC_DIR |= 1<<pin;
 4da:	01 e0       	ldi	r16, 0x01	; 1
 4dc:	10 e0       	ldi	r17, 0x00	; 0
			for(uint8_t i = 0; i < numPins - 1; i++){
				pin = (uint8_t)va_arg(valist, int);
				
				if(pin == 6){
					// miso pin
					PORTC_DIRCLR = 1<<pin;
 4de:	0f 2e       	mov	r0, r31
 4e0:	f2 e4       	ldi	r31, 0x42	; 66
 4e2:	ef 2e       	mov	r14, r31
 4e4:	f6 e0       	ldi	r31, 0x06	; 6
 4e6:	ff 2e       	mov	r15, r31
 4e8:	f0 2d       	mov	r31, r0
			pin = (uint8_t)va_arg(valist, int);
			PORTC_DIR |= 1<<pin;
			
			// get the remaining pins
			for(uint8_t i = 0; i < numPins - 1; i++){
				pin = (uint8_t)va_arg(valist, int);
 4ea:	fc 01       	movw	r30, r24
 4ec:	30 81       	ld	r19, Z
 4ee:	02 96       	adiw	r24, 0x02	; 2
				
				if(pin == 6){
 4f0:	36 30       	cpi	r19, 0x06	; 6
 4f2:	49 f4       	brne	.+18     	; 0x506 <spiBegin+0x100>
					// miso pin
					PORTC_DIRCLR = 1<<pin;
 4f4:	a8 01       	movw	r20, r16
 4f6:	02 c0       	rjmp	.+4      	; 0x4fc <spiBegin+0xf6>
 4f8:	44 0f       	add	r20, r20
 4fa:	55 1f       	adc	r21, r21
 4fc:	3a 95       	dec	r19
 4fe:	e2 f7       	brpl	.-8      	; 0x4f8 <spiBegin+0xf2>
 500:	f7 01       	movw	r30, r14
 502:	40 83       	st	Z, r20
 504:	09 c0       	rjmp	.+18     	; 0x518 <spiBegin+0x112>
					}else{
					// the rest are outputs
					PORTC_DIR |= 1<<pin;
 506:	ec 91       	ld	r30, X
 508:	a8 01       	movw	r20, r16
 50a:	02 c0       	rjmp	.+4      	; 0x510 <spiBegin+0x10a>
 50c:	44 0f       	add	r20, r20
 50e:	55 1f       	adc	r21, r21
 510:	3a 95       	dec	r19
 512:	e2 f7       	brpl	.-8      	; 0x50c <spiBegin+0x106>
 514:	4e 2b       	or	r20, r30
 516:	4c 93       	st	X, r20
			// the first pin is always mosi
			pin = (uint8_t)va_arg(valist, int);
			PORTC_DIR |= 1<<pin;
			
			// get the remaining pins
			for(uint8_t i = 0; i < numPins - 1; i++){
 518:	2f 5f       	subi	r18, 0xFF	; 255
 51a:	42 2f       	mov	r20, r18
 51c:	50 e0       	ldi	r21, 0x00	; 0
 51e:	46 17       	cp	r20, r22
 520:	57 07       	cpc	r21, r23
 522:	1c f3       	brlt	.-58     	; 0x4ea <spiBegin+0xe4>
					PORTC_DIR |= 1<<pin;
				}
			}
			
			// enable SPID, master mode, clk/4 = 8MHz
			SPID_CTRL = (1<<SPI_ENABLE_bp | 1<<SPI_MASTER_bp);
 524:	80 e5       	ldi	r24, 0x50	; 80
 526:	80 93 c0 09 	sts	0x09C0, r24
			break;
	}
	
	// clean up memory from valist
	va_end(valist);
}
 52a:	df 91       	pop	r29
 52c:	cf 91       	pop	r28
 52e:	1f 91       	pop	r17
 530:	0f 91       	pop	r16
 532:	ff 90       	pop	r15
 534:	ef 90       	pop	r14
 536:	08 95       	ret

00000538 <spiWrite>:

void spiWrite(uint16_t port, uint8_t data){
	switch(port){
 538:	00 97       	sbiw	r24, 0x00	; 0
 53a:	19 f0       	breq	.+6      	; 0x542 <spiWrite+0xa>
 53c:	01 97       	sbiw	r24, 0x01	; 1
 53e:	49 f0       	breq	.+18     	; 0x552 <spiWrite+0x1a>
 540:	08 95       	ret
		case SPI_PORTC:
			// load data into register and wait for transfer
			SPIC_DATA = data;
 542:	60 93 c3 08 	sts	0x08C3, r22
			while(!(SPIC_STATUS & SPI_IF_bm));
 546:	e2 ec       	ldi	r30, 0xC2	; 194
 548:	f8 e0       	ldi	r31, 0x08	; 8
 54a:	80 81       	ld	r24, Z
 54c:	88 23       	and	r24, r24
 54e:	ec f7       	brge	.-6      	; 0x54a <spiWrite+0x12>
 550:	08 95       	ret
			break;
		case SPI_PORTD:
			// load data into register and wait for transfer
			SPID_DATA = data;
 552:	60 93 c3 09 	sts	0x09C3, r22
			while(!(SPID_STATUS & SPI_IF_bm));
 556:	e2 ec       	ldi	r30, 0xC2	; 194
 558:	f9 e0       	ldi	r31, 0x09	; 9
 55a:	80 81       	ld	r24, Z
 55c:	88 23       	and	r24, r24
 55e:	ec f7       	brge	.-6      	; 0x55a <spiWrite+0x22>
 560:	08 95       	ret

00000562 <_exit>:
 562:	f8 94       	cli

00000564 <__stop_program>:
 564:	ff cf       	rjmp	.-2      	; 0x564 <__stop_program>
